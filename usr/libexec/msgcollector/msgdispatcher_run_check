#!/bin/bash

## Copyright (C) 2012 - 2023 ENCRYPTED SUPPORT LP <adrelanos@whonix.org>
## See the file COPYING for copying conditions.

msgdispatcher_pid_check() {
   local pid_file pid

   if [ "cli" = "$1" ]; then
      pid_file="${msgcollector_run_dir}/msgdispatcher_pidcli"
   elif [ "x" = "$1" ]; then
      pid_file="${msgcollector_run_dir}/msgdispatcher_pidx"
   else
      error "$FUNCNAME neither cli nor x is set to 1."
   fi

   if test -f "$pid_file" ; then
      true "$0: $FUNCNAME: pid_file $pid_file exists, ok."
      return 0
   fi

   true "$0: $FUNCNAME: pid_file $pid_file does NOT exist."
   return 1

   ## hidepid=2 broke this
   #pid="$(cat "$pid_file")" || return 5
   ## `kill` does not work if running under a different user account then set
   ## in variable `who_ami`, therefore using `ps`.
   #kill -0 "$pid" >/dev/null 2>&1 || return 6
   #ps -p "$pid" >/dev/null 2>&1 || return 6
}

msgdispatcher_run_check() {
   source /usr/libexec/msgcollector/msgcollector_shared
   ## sets: ${msgcollector_run_dir}
   folder_init

   if msgdispatcher_pid_check "x" ; then
      msgdispatcher_running_x="true"
   fi
   if msgdispatcher_pid_check "cli" ; then
      msgdispatcher_running_cli="true"
   fi
}

msgdispatcher_init() {
   output_tool="/usr/libexec/msgcollector/msgcollector"
   output_general="output_func_general"
   output_x="output_func_x"
   output_cli="output_func_cli"
   msgdispatcher_run_check
   msgdispatcher_wait
}

msgdispatcher_wait() {
   while true; do
      if [ "$msgdispatcher_running_x" = "true" ] || [ "$msgdispatcher_running_cli" = "true" ]; then
         break
      fi
      loop_protection
   done
}

output_func_general() {
   output_func "$@"
   return "$?"
}

output_func_x() {
   if [ "$msgdispatcher_running_x" = "true" ]; then
      output_func "$@"
      return "$?"
   fi
   true "$0: $FUNCNAME: skipping because msgdispatcher_running_x is not set to true."
}

output_func_cli() {
   if [ "$msgdispatcher_running_cli" = "true" ]; then
      output_func "$@"
      return "$?"
   fi
   true "$FUNCNAME: injecting --onlyecho."
   output_func --onlyecho "$@"
}

output_func() {
   local output_text
   output_text=( "$@" )

   ## check ARG_MAX
   if /bin/echo "$@" &>/dev/null ; then
      true "INFO: ARG_MAX test passed, ok."
   else
      true "WARNING: ARG_MAX test failed."

      ## remove last parameter, presumably the MSG from "$@"
      ## same in other words:
      ## remove last parameter, presumably the message from args
      ## https://stackoverflow.com/a/20398578/2605155
      unset "output_text[${#output_text[@]}-1]"

      debug_information="\
${FUNCNAME[0]} was called with too many arguments.
\${FUNCNAME[0]}: ${FUNCNAME[0]}
\${FUNCNAME[1]}: ${FUNCNAME[1]}
\${FUNCNAME[2]}: ${FUNCNAME[2]}
\${FUNCNAME[3]}: ${FUNCNAME[4]}
\${FUNCNAME[5]}: ${FUNCNAME[5]}
\${FUNCNAME[6]}: ${FUNCNAME[6]}
\$0: $0" || true

      output_text+=("ERROR: ARG_MAX exceeded!

debug information:
$debug_information")
   fi

   true before: "$@ BEFORE"
   true after : "${output_text[@]} AFTER"

   if [ "$output_func_verbose" = "true" ]; then
      echo "Running: bash -x $output_tool --identifier $IDENTIFIER ${1+$@}"
      bash -x $output_tool --identifier "$IDENTIFIER" "${output_text[@]}"
   else
      $output_tool --identifier "$IDENTIFIER" "${output_text[@]}"
   fi
   return "$?"
}
