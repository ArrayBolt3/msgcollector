#!/bin/bash

## This file is part of Whonix.
## Copyright (C) 2012 - 2014 Patrick Schleizer <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

#set -x
set -o pipefail

scriptname="$(basename "$BASH_SOURCE")"

error_handler() {
   local exit_code="$?"

   local msg="<p>
<br></br>###############################################################################
<br></br>## $scriptname script bug.
<br></br>## No panic. Nothing is broken. Just some rare condition has been hit.
<br></br>## Try again later. There is likely a solution for this problem.
<br></br>## Please see Whonix News, Whonix Blog and Whonix User Help Forum.
<br></br>## Please report this bug!
<br></br>##
<br></br>## BASH_COMMAND: $BASH_COMMAND
<br></br>## exit_code: $exit_code
<br></br>###############################################################################</p>"

   ## Popup window with the message above.
   ## /usr/share/icons/anon-icon-pack/whonix.ico might not exist, but
   ## fortunately msgdispatcher_dispatch_x works anyway.
   /usr/lib/msgcollector/msgdispatcher_dispatch_x "warning" "$scriptname" "$msg" "0" "/usr/share/icons/anon-icon-pack/whonix.ico" &

   local stripped_msg
   stripped_msg="$(/usr/lib/msgcollector/striphtml "$msg")"
   if [ "$stripped_msg" = "" ]; then
      ## In case striphtml failed or is not available.
      echo "$msg" >&2
   else
      echo "$stripped_msg" >&2
   fi
   if [ ! -d ~/".msgcollector" ]; then
      mkdir --parents ~/".msgcollector"
   fi
   echo "$scriptname: BASH_COMMAND: $BASH_COMMAND | exit_code: $exit_code" >> ~/".msgcollector/msgdispatcher-error.log"

   true
}

trap "error_handler" ERR

trap_sighup() {
   set -x
   true
   exit 0
}

trap "trap_sighup" SIGHUP

parse_cmd_options() {
   trap "error_handler" ERR

   ## Thanks to:
   ## http://mywiki.wooledge.org/BashFAQ/035

   while true; do
       case $1 in
           --verbose)
               set -x
               verbose="1"
               shift
               ;;
           --cli)
               cli="1"
               shift
               ;;
           --x)
               x="1"
               shift
               ;;
           --)
               shift
               break
               ;;
           -*)
               echo "$scriptname unknown option: $type" >&2
               exit 1
               ;;
           *)
               break
               ;;
       esac
   done
}

preparation() {
   trap "error_handler" ERR

   if [ "$who_ami" = "" ]; then
      who_ami="$(whoami)"
   fi

   if [ ! -d "/var/run/msgcollector/$who_ami" ]; then
      mkdir --mode o+rwx --parents "/var/run/msgcollector/$who_ami"
   fi
}

write_own_pid() {
   trap "error_handler" ERR

   if [ "$cli" = "1" ]; then
      echo "$$" > "/var/run/msgcollector/$who_ami/msgdispatcher_pidcli"
   elif [ "$x" = "1" ]; then
      echo "$$" > "/var/run/msgcollector/$who_ami/msgdispatcher_pidx"
   else
      echo "$$" > "/var/run/msgcollector/$who_ami/msgdispatcher_piderror"
      exit 3
   fi
}

## {{ Small wrapper to use either kdialog, notify-send or nothing.
passive_popup_tool() {
   trap "error_handler" ERR

   local time text
   time="$1"
   text="$2"

   ## check if kdialog, notify-send or no passive popup tool is installed
   ## - that is not the case for CLI Custom-Workstation users
   ## - that may not be the case for Gnome users
   if [ ! "$(command -v "kdialog")" = "" ] ; then
      ## Use $identifier as short title.
      kdialog --title "$identifier" --passivepopup "$text" "$time"
   elif [ ! "$(command -v "notify-send")" = "" ] ; then
      ## Use $identifier as short title.
      notify-send --expire-time "$time" "$identifier" "$text"
   else
      true
   fi
}
## }}

dispatch_cli() {
   trap "error_handler" ERR

   local msg
   msg="$1"

   if [ -f "/var/run/msgcollector/$who_ami/${identifier}.parenttty" ]; then
      local parenttty
      parenttty="$(cat "/var/run/msgcollector/$who_ami/${identifier}.parenttty")"
      if [ "$parenttty" = "/dev/tty1" ]; then
         ## When for example whonixcheck was run in tty1, then messages were
         ## already echoed by msgcollector. No need to dispatch them again.
         true "Skipping, because parenttty is /dev/tty1."
         return 0
      fi
   fi

   echo "$msg"
}

dispatch_x_active() {
   trap "error_handler" ERR

   if [ -f "/var/run/msgcollector/$who_ami/${identifier}.lefttop" ]; then
      local lefttop
      lefttop="1"
   fi

   local icon
   if [ -f "/var/run/msgcollector/$who_ami/${identifier}.icon" ]; then
      icon="$(cat "/var/run/msgcollector/$who_ami/${identifier}.icon")"
   else
      ## Fallback.
      icon="/usr/share/icons/anon-icon-pack/whonix.ico"
   fi

   ## Fallback.
   if [ "$type" = "" ]; then
      type="info"
   fi

   if [ "$verbose" = "1" ]; then
      /usr/lib/msgcollector/msgdispatcher_dispatch_x "$type" "$title" "$msg" "$lefttop" "$icon"
   else
      ## Launching into background, so it doesn't block msgdispatcher until
      ## msgdispatcher_dispatch_x exits.
      /usr/lib/msgcollector/msgdispatcher_dispatch_x "$type" "$title" "$msg" "$lefttop" "$icon" &
   fi
}

dispatch_x_passive() {
   trap "error_handler" ERR

   passive_popup_tool "20" "$msg"
}

inotifywait_loop() {
   trap "error_handler" ERR

   shopt -s nullglob

   local identifier temp_item file_name

   inotifywait --quiet --recursive --monitor --event create --format "%w%f" "/var/run/msgcollector/$who_ami" | while read -r file_name; do
      unset identifier temp_item

      file_extension="${file_name##*.}"
      if [ ! "$file_extension" = "done" ]; then
         continue
      fi

      ## Remove ".done".
      temp_item="${file_name%%.*}"
      ## Remove "/var/run/msgcollector/$who_ami/".
      identifier="${temp_item##*/}"

      if [ "$x" = "1" ]; then
         local progressbaridx_file
         ## The * matches progressbaridx.
         for progressbaridx_file in /var/run/msgcollector/$who_ami/${identifier}.*.progressbarx.done; do
            first_two="${progressbaridx_file%.*.*}"
            progressbaridx=${first_two##*.}
            if [ -f "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.progressbarx.done" ]; then
               if [ -f "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.progressbarx" ]; then
                  if [ -f "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.progressbarx.animate" ]; then
                     rm --force "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.progressbarx.animate"
                     animate="--animate"
                  else
                     unset animate
                  fi
                  if [ "$verbose" = "1" ]; then
                     bash -x /usr/lib/msgcollector/msgprogressbar --identifier "$identifier" --whoami "$who_ami" --progressbaridx "${progressbaridx}" --verbose $animate
                  else
                     /usr/lib/msgcollector/msgprogressbar --identifier "$identifier" --whoami "$who_ami" --progressbaridx "${progressbaridx}" $animate &
                  fi
                  unset animate
                  rm --force "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.progressbarx.done"
               else
                  rm --force "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.progressbarx.done"
               fi
               continue
            fi
         done
         unset progressbaridx_file

         if [ "$file_name" = "/var/run/msgcollector/$who_ami/${identifier}.waitmessagex.done" ]; then
            if [ -f "/var/run/msgcollector/$who_ami/${identifier}.waitmessagex" ]; then
               msg="$(cat "/var/run/msgcollector/$who_ami/${identifier}.waitmessagex")"
               ## TODO
               title="$(cat "/var/run/msgcollector/$who_ami/${identifier}.titlex")" || true
               type="$(cat "/var/run/msgcollector/$who_ami/${identifier}.typex")"
               dispatch_x_passive "$type" "$msg"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.waitmessagex.done"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.waitmessagex"
            else
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.waitmessagex.done"
            fi
            continue
         fi
         if [ "$file_name" = "/var/run/msgcollector/$who_ami/${identifier}.messagex.done" ]; then
            if [ -f "/var/run/msgcollector/$who_ami/${identifier}.messagex" ]; then
               msg="$(cat "/var/run/msgcollector/$who_ami/${identifier}.messagex")"
               ## TODO: prevent race condition; own titlex for messagex, passivepopupqueuex
               title="$(cat "/var/run/msgcollector/$who_ami/${identifier}.titlex")" || true
               type="$(cat "/var/run/msgcollector/$who_ami/${identifier}.typex")"
               dispatch_x_active "$type" "$msg"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.messagex.done"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.messagex"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.lefttop"
            else
               ## Not using rm outside the if, to prevent race conditions.
               ## Not always using rm, without if to prevent forking.
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.messagex.done"
            fi
            continue
         fi
         if [ "$file_name" = "/var/run/msgcollector/$who_ami/${identifier}.passivepopupqueuex.done" ]; then
            if [ -f "/var/run/msgcollector/$who_ami/${identifier}.passivepopupqueuex" ]; then
               msg="$(cat "/var/run/msgcollector/$who_ami/${identifier}.passivepopupqueuex")"
               ## TODO: prevent race condition; own titlex for messagex, passivepopupqueuex
               title="$(cat "/var/run/msgcollector/$who_ami/${identifier}.titlex")" || true
               type="$(cat "/var/run/msgcollector/$who_ami/${identifier}.typex")"
               if [ -f "/var/run/msgcollector/$who_ami/${identifier}.forceactive" ]; then
                  dispatch_x_active "$type" "$msg"
               else
                  dispatch_x_passive "$type" "$msg"
               fi
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.forceactive"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.passivepopupqueuex.done"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.passivepopupqueuex"
            else
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.passivepopupqueuex.done"
            fi
            continue
         fi

      elif [ "$cli" = "1" ]; then
         if [ "$file_name" = "/var/run/msgcollector/$who_ami/${identifier}.waitmessagecli.done" ]; then
            if [ -f "/var/run/msgcollector/$who_ami/${identifier}.waitmessagecli" ]; then
               msg="$(cat "/var/run/msgcollector/$who_ami/${identifier}.waitmessagecli")"
               type="$(cat "/var/run/msgcollector/$who_ami/${identifier}.typecli")"
               dispatch_cli "$msg"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.waitmessagecli.done"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.waitmessagecli"
            else
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.waitmessagecli.done"
            fi
            continue
         fi
         if [ "$file_name" = "/var/run/msgcollector/$who_ami/${identifier}.messagecli.done" ]; then
            if [ -f "/var/run/msgcollector/$who_ami/${identifier}.messagecli" ]; then
               msg="$(cat "/var/run/msgcollector/$who_ami/${identifier}.messagecli")"
               type="$(cat "/var/run/msgcollector/$who_ami/${identifier}.typecli")"
               dispatch_cli "$msg"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.messagecli.done"
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.messagecli"
            else
               rm --force "/var/run/msgcollector/$who_ami/${identifier}.messagecli.done"
            fi
            continue
         fi
      else
         exit 1
      fi
   done
}

msgdispatcher_loop() {
   trap "error_handler" ERR
   while true; do
      preparation
      write_own_pid
      fallbacks ## provided by /usr/lib/msgcollector/msgwmctrl
      inotifywait_loop
      sleep 2 &
      wait "$!"
   done
}

source /usr/lib/msgcollector/msgcollector_shared
source /usr/lib/msgcollector/msgwmctrl

parse_cmd_options ${1+"$@"}
msgdispatcher_loop
