#!/bin/bash

## This file is part of Whonix.
## Copyright (C) 2012 - 2018 Patrick Schleizer <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

#set -x
#exec >  >(tee -a "/home/user/msgprogressbarlog")
#exec 2> >(tee -a "/home/user/msgprogressbarlog" >&2)

set -o pipefail

scriptname="$(basename "$BASH_SOURCE")"

error_handler() {
   local exit_code="$?"

   local msg="\
###############################################################################
## $scriptname script bug.
## No panic. Nothing is broken. Just some rare condition has been hit.
## Try again later. There is likely a solution for this problem.
## Please see Whonix News, Whonix Blog and Whonix User Help Forum.
## Please report this bug!
##
## BASH_COMMAND: $BASH_COMMAND
## exit_code: $exit_code
###############################################################################\
"
   echo "$msg" >&2
   if [ ! -d ~/".msgcollector" ]; then
      mkdir --parents ~/".msgcollector"
   fi
   echo "$scriptname: BASH_COMMAND: $BASH_COMMAND | exit_code: $exit_code" >> ~/".msgcollector/msgdispatcher-error.log"
   exit 1
}

trap "error_handler" ERR

parse_cmd_options() {
   trap "error_handler" ERR

   ## Thanks to:
   ## http://mywiki.wooledge.org/BashFAQ/035

   while true; do
       case $1 in
           --verbose)
               set -x
               verbose="1"
               shift
               ;;
           --identifier)
               identifier="$2"
               shift 2
               ;;
           --whoami)
               who_ami="$2"
               shift 2
               ;;
           --progressbaridx)
               progressbaridx="$2"
               shift 2
               ;;
           --progressbartitlex)
               progressbartitlex="$2"
               shift 2
               ;;
           --progressbarx)
               progressbarx="$2"
               shift 2
               ;;
           --animate)
               animate="1"
               shift
               ;;
           --)
               shift
               break
               ;;
           -*)
               echo "$scriptname unknown option: $type" >&2
               exit 1
               ;;
           *)
               break
               ;;
       esac
   done

   ## If there are input files (for example) that follow the options, they
   ## will remain in the "$@" positional parameters.
}

preparation() {
   trap "error_handler" ERR

   if [ "$who_ami" = "" ]; then
      who_ami="$(whoami)"
   fi

   if [ ! -d "/var/run/msgcollector/$who_ami" ]; then
      mkdir --mode o+rwx --parents "/var/run/msgcollector/$who_ami"
   fi

   fifo="/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.fifo"
   progress_txt_file="/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.progresstxt"
}

cleanup_self() {
   trap "error_handler" ERR

   true "$0 $FUNCNAME: killing zenity_progress_pid $zenity_progress_pid..."
   kill -sigterm "$zenity_progress_pid" >/dev/null 2>/dev/null || true
   rm --force "$fifo"
   rm --force "$progress_txt_file"
   rm --force "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.zenityprogresspid"
   rm --force "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.parentpid"
}

output_ex() {
   trap "error_handler" ERR

   ## This function is called when the cancel button in zenity gets pressed or
   ## when $progress_txt_file contains 100.

   ## Debugging.
   #echo "progress: $progress | caller: $PPID | $caller | killing $zenity_progress_pid" >> /home/user/progresslog

   if [ -f "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.parentpid" ]; then
      sudo --non-interactive "/usr/lib/msgcollector/msgprogressbar_kill_helper" "$who_ami" "${identifier}" "${progressbaridx}"
   else
      true "$output_signal_caught caught. Not killing parentpid $parentpid, \
because /var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.parentpid does not exist."
   fi

   cleanup_self
   exit 0
}

output_sighup() {
   trap "error_handler" ERR
   output_signal_caught="SIGHUP"
   output_ex
}

trap "output_sighup" SIGHUP

output_sigterm() {
   trap "error_handler" ERR
   output_signal_caught="SIGTERM"
   output_ex
}

trap "output_sigterm" SIGTERM

start_progress_bar() {
   trap "error_handler" ERR

   if [ "$progressbarx" = "" ]; then
      progressbarx="Progress bar message is empty, please report this Whonix bug!"
   fi

   if [ "$progressbartitlex" = "" ]; then
      progressbartitlex="Variable progressbartitlex does not exist. Please report this bug!"
   fi

   if [ -f "/var/run/msgcollector/$who_ami/${identifier}.icon" ]; then
      local icon
      icon="$(cat "/var/run/msgcollector/$who_ami/${identifier}.icon")"
   fi

   if [ "$icon" = "" ]; then
      ## TODO: write error log
      local icon="/usr/share/icons/anon-icon-pack/whonix.ico"
   fi

   if [ -f "/var/run/msgcollector/$who_ami/${identifier}.lefttop" ]; then
      local lefttop="1"
   fi

   if [ "$display" = "" ]; then
      display=":0"
   fi

   if [ -f "$progress_txt_file" ]; then
      ## Sometimes there is a race condition preventing the progressbar
      ## being closed. Let's use this alternative approach.
      progress_txt_file_progress="$(cat "$progress_txt_file")"
      if [ "$progress_txt_file_progress" = "100" ]; then
         true "Already 100%. Not even opening progress bar."
         cleanup_self
         exit 0
      fi
   fi

   ## Sanity test for $progress_txt_file_progress, because we use it without
   ## quotes as argument for zenity below.
   ## Also matches $when progress_txt_file_progress is unset.
   if [[ "$progress_txt_file_progress" != *[!0-9]* ]]; then
      true "'$progress_txt_file_progress' is strictly numeric."
   else
      error "'$progress_txt_file_progress' is NOT strictly numeric!"
      exit 1
   fi

   if [ ! "$progress_txt_file_progress" = "" ]; then
      percentage_maybe_add="--percentage $progress_txt_file_progress"
   fi

   ## Clean up eventual old progress bar.
   rm --force "$fifo"

   mkfifo "$fifo"

   ## Do not use < > inside zenity progress messages, zenity will mess that up.
   ## zenity --auto-kill will result in zenity sending a sighup signal upon
   ## pressing of cancel button.
   zenity \
      --display="$display" \
      --timeout "86400" \
      --no-markup \
      --window-icon "$icon" \
      --title="$progressbartitlex" \
      --auto-kill \
      --auto-close \
      --progress \
      $percentage_maybe_add \
      --text "$progressbarx" \
      < "$fifo" & zenity_progress_pid="$!"

   exec 3>"$fifo"

   echo "$zenity_progress_pid" > "/var/run/msgcollector/$who_ami/${identifier}.${progressbaridx}.zenityprogresspid"

   if [ "$lefttop" = "1" ]; then
      ## set progressbar variable to 1, so the progress bar window will not be
      ## maximized by output_wmctrl.
      progressbar="1"

      ## provided by /usr/lib/msgcollector/msgwmctrl
      output_wmctrl_move_window_to_left_top "$progressbartitlex"
   fi

   while true; do
      if [ -f "$progress_txt_file" ]; then
         ## Sometimes there is a race condition preventing the progressbar
         ## being closed. Let's use this alternative approach.
         progress_txt_file_progress="$(cat "$progress_txt_file")"
         if [ "$progress_txt_file_progress" = "100" ]; then
            cleanup_self
            exit 0
         fi
      fi
      ## Alternatively (most cases) waiting for SIGHUP.
      ## Happens when zentiy reached 100% or when cancel button is pressed.
      ## This will call the output_sighup function.

      ## Check if still running.
      local ps__p_exit_code
      ps__p_exit_code="0"
      ps -p "$zenity_progress_pid" >/dev/null 2>/dev/null || { ps__p_exit_code="$?"; true; };
      if [ ! "$ps__p_exit_code" = "0" ]; then
         cleanup_self
         exit 0
      fi

      sleep "2" &
      wait "$!"
   done
}

source /usr/lib/msgcollector/msgwmctrl
fallbacks ## provided by /usr/lib/msgcollector/msgwmctrl
parse_cmd_options "$@"
preparation
start_progress_bar
